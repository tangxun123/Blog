<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>浏览器渲染机制 | TXBLOG</title>
    <meta name="generator" content="VuePress 1.5.2">
    
    <meta name="description" content="Vue 驱动的静态网站生成器">
    <link rel="preload" href="/assets/css/0.styles.d727f307.css" as="style"><link rel="preload" href="/assets/js/app.5be7a91d.js" as="script"><link rel="preload" href="/assets/js/2.b81dff88.js" as="script"><link rel="preload" href="/assets/js/10.c01ab306.js" as="script"><link rel="prefetch" href="/assets/js/11.c65a40d7.js"><link rel="prefetch" href="/assets/js/12.ec3c1912.js"><link rel="prefetch" href="/assets/js/13.06c44e9f.js"><link rel="prefetch" href="/assets/js/14.8a2d11d9.js"><link rel="prefetch" href="/assets/js/15.91e2472b.js"><link rel="prefetch" href="/assets/js/16.03254a66.js"><link rel="prefetch" href="/assets/js/17.de86a416.js"><link rel="prefetch" href="/assets/js/18.98d4714b.js"><link rel="prefetch" href="/assets/js/19.fd72dab3.js"><link rel="prefetch" href="/assets/js/20.b09651e7.js"><link rel="prefetch" href="/assets/js/21.e441010a.js"><link rel="prefetch" href="/assets/js/22.040838f3.js"><link rel="prefetch" href="/assets/js/23.1dce59bb.js"><link rel="prefetch" href="/assets/js/24.eeb5c7c3.js"><link rel="prefetch" href="/assets/js/25.5f918b35.js"><link rel="prefetch" href="/assets/js/26.32b91ce1.js"><link rel="prefetch" href="/assets/js/27.d8758cbc.js"><link rel="prefetch" href="/assets/js/28.d0dd92f3.js"><link rel="prefetch" href="/assets/js/3.e119212f.js"><link rel="prefetch" href="/assets/js/4.7a02083b.js"><link rel="prefetch" href="/assets/js/5.b44834bc.js"><link rel="prefetch" href="/assets/js/6.03d1d276.js"><link rel="prefetch" href="/assets/js/7.05c6b1cc.js"><link rel="prefetch" href="/assets/js/8.ce808feb.js"><link rel="prefetch" href="/assets/js/9.2c631e92.js">
    <link rel="stylesheet" href="/assets/css/0.styles.d727f307.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">TXBLOG</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/SideBar/Interview/interview.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  面试重点
</a></div><div class="nav-item"><a href="/SideBar/studyMenus/npm.html" class="nav-link">
  学习随笔
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Study Menu" class="dropdown-title"><span class="title">知识点</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/SideBar/Git/Git工作流程及规范.html" class="nav-link">
  Git
</a></li><li class="dropdown-item"><!----> <a href="/SideBar/DOM/DOM.html" class="nav-link">
  DOM
</a></li><li class="dropdown-item"><!----> <a href="/SideBar/Vue/组件传值.html" class="nav-link">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/SideBar/React/Hook.html" class="nav-link">
  React
</a></li><li class="dropdown-item"><!----> <a href="/SideBar/ReactNative/启动页空白.html" class="nav-link">
  ReactNative
</a></li><li class="dropdown-item"><!----> <a href="/SideBar/Canvas/canvas.html" class="nav-link">
  canvas
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/SideBar/Interview/interview.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  面试重点
</a></div><div class="nav-item"><a href="/SideBar/studyMenus/npm.html" class="nav-link">
  学习随笔
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Study Menu" class="dropdown-title"><span class="title">知识点</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/SideBar/Git/Git工作流程及规范.html" class="nav-link">
  Git
</a></li><li class="dropdown-item"><!----> <a href="/SideBar/DOM/DOM.html" class="nav-link">
  DOM
</a></li><li class="dropdown-item"><!----> <a href="/SideBar/Vue/组件传值.html" class="nav-link">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/SideBar/React/Hook.html" class="nav-link">
  React
</a></li><li class="dropdown-item"><!----> <a href="/SideBar/ReactNative/启动页空白.html" class="nav-link">
  ReactNative
</a></li><li class="dropdown-item"><!----> <a href="/SideBar/Canvas/canvas.html" class="nav-link">
  canvas
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="浏览器渲染机制"><a href="#浏览器渲染机制" class="header-anchor">#</a> 浏览器渲染机制</h2> <ol><li>HTML和CSS经过各自解析，生成DOM树和CSSOM树；</li> <li>合并成为渲染树 rendertree；</li> <li>根据渲染树进行布局layout；</li> <li>最后调用GPU进行绘制，显示在屏幕上paint。</li></ol> <h2 id="gpu加速"><a href="#gpu加速" class="header-anchor">#</a> GPU加速</h2> <p>优点：使用transform、opacity、filters等属性时，会直接在GPU中完成处理，这些属性的变化不会引起回流重绘；
缺点：GPU渲染字体会导致字体模糊，过多的GPU处理会导致内存问题。</p> <h2 id="h5c3新特性"><a href="#h5c3新特性" class="header-anchor">#</a> H5C3新特性</h2> <p>H5</p> <p>①新增多媒体标签	②新增语义化标签	③新增表单控件	④新增表单属性	⑤新增利用<code>JS</code>绘图的画布元素	⑥WEB存储	⑦DOM扩展（获取DOM的方式）	⑧自定义属性dataset等；</p> <p>C3</p> <p>①新增选择器	②过渡，转换（<code>2D/3D</code>），动画 	③边框(边框圆角，边框图片)	④颜色(<code>rgba</code>)	⑤背景(<code>bgs</code>)	⑥盒子阴影	⑦文字(文字阴影，单行文本省略)	⑧盒模型(标准，怪异)	⑨媒体查询(media) 	⑩flex弹性布局等。</p> <h2 id="动画"><a href="#动画" class="header-anchor">#</a> 动画</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/* animation: 动画名称 持续时间 运动曲线 何时开始 播放次数 是否反方向 起始与结束状态 */</span>
animation<span class="token operator">:</span> name duration timing<span class="token operator">-</span><span class="token keyword">function</span> delay iteration<span class="token operator">-</span>count direction fill<span class="token operator">-</span>mode
animation<span class="token operator">-</span>play<span class="token operator">-</span>state<span class="token operator">:</span> paused<span class="token punctuation">;</span>
</code></pre></div><h2 id="使一个盒子水平垂直居中"><a href="#使一个盒子水平垂直居中" class="header-anchor">#</a> 使一个盒子水平垂直居中</h2> <p>①利用子绝父相和transform里面的translate ;</p> <p>②利用flex弹性布局 ;</p> <p>③父盒子利用display：table-cell，vertical-align，text-align，子盒子转行内块。(父盒子有固定的宽高)</p> <h2 id="flex布局"><a href="#flex布局" class="header-anchor">#</a> flex布局</h2> <p>父元素属性:</p> <p><code>justify-content:</code>定义了子元素在主轴上的对齐方式；</p> <p><code>align-items:</code>定义了定义项目在次轴上对齐方式；</p> <p><code>flex-direction:</code>定义主轴方向；</p> <p><code>flex-wrap:</code>定义换行方式；</p> <p><code>flex-flow:</code>flex-direction和flex-wrap复合写法；</p> <p><code>align-content:</code>定义多根轴线的对齐方式。</p> <p>子元素属性</p> <p><code>flex: flex-grow flex-shrink flex-basis 0 1 auto</code>;</p> <p><code>order:</code>定义项目的排列顺序。数值越小，排列越靠前，默认为0;</p> <p><code>align-self:</code>定义单个子元素的排列方式。</p> <h2 id="什么是bfc"><a href="#什么是bfc" class="header-anchor">#</a> 什么是BFC</h2> <p>BFC全称 <code>Block Formatting Context</code>即<code>块级格式上下文</code>，简单的说，BFC是页面上的一个隔离的独立容器(渲染控件)，不受外界干扰或干扰外界。</p> <p><strong>如何触发BFC</strong></p> <ul><li><code>float</code>不为 none；</li> <li><code>overflow</code>的值不为 visible；</li> <li><code>position</code> 为 absolute 或 fixed；</li> <li><code>display</code>的值为 inline-block 或 table-cell 或 table-caption 或 grid；</li></ul> <p><strong>BFC的应用场景</strong></p> <ul><li><strong>清除浮动</strong>：BFC内部的浮动元素会参与高度计算，因此可用于清除浮动，防止高度塌陷；</li> <li><strong>避免某元素被浮动元素覆盖</strong>：BFC的区域不会与浮动元素的区域重叠；</li> <li><strong>阻止外边距重叠</strong>：属于同一个BFC的两个相邻Box的margin会发生折叠，不同BFC不会发生折叠。</li></ul> <h2 id="viewport视口"><a href="#viewport视口" class="header-anchor">#</a> viewport视口</h2> <ul><li>width/height，宽高，默认宽度980px；</li> <li>initial-scale，初始缩放比例，1~10；</li> <li>maximum-scale/minimum-scale，允许用户缩放的最大/小比例；</li> <li>user-scalable，用户是否可以缩放 (yes/no)；</li></ul> <h2 id="数组的方法和拓展"><a href="#数组的方法和拓展" class="header-anchor">#</a> 数组的方法和拓展</h2> <p><strong>数组判断</strong></p> <p>arr  instanceof Array</p> <p>Array.from()</p> <p><strong>增删</strong></p> <p>push()末尾添加数组元素，返回新数组长度;</p> <p>unshift()头部添加数组元素，返回新数组长度;</p> <p>pop()删除末尾数组元素，返回删除的数组元素;</p> <p>shift()删除头部数组元素，返回删除的数组元素;</p> <p><strong>排序</strong></p> <p>arr.sort()</p> <p>arr.reserve()</p> <p><strong>迭代</strong></p> <p>arr.forEach()</p> <p>arr.map()</p> <p>arr.filter()</p> <p>arr.some和arr.every()</p> <p>arr.find()</p> <p>arr.findIndex()</p> <p>arr.inclides()</p> <p>arr.float()</p> <p>arr.reduce()</p> <p><strong>索引</strong></p> <p>arr.indexOf()</p> <p>arr.lastIndexOf()</p> <p><strong>转字符串</strong></p> <p>toString()</p> <p>arr.join()</p> <p><strong>其他方法</strong></p> <p>concat()合并  返回一个新数组</p> <p>slice(start，end)截取  返回截取的数组</p> <p>splice(index，howmany，item)删除添加  返回截取的数组</p> <h2 id="字符串方法和拓展"><a href="#字符串方法和拓展" class="header-anchor">#</a> 字符串方法和拓展</h2> <p><strong>索引</strong></p> <p>string.indexOf()</p> <p>string.lastIndexOf()</p> <p><strong>位置</strong></p> <p>charAt(index)</p> <p>chaCodeAt(index)</p> <p>str[index]</p> <p><strong>转数组</strong></p> <p>string.split('分隔符')</p> <p><strong>其他方法</strong></p> <p>concat()拼接字符串</p> <p>slice(start，end)截取字符串</p> <p>substring(start，end)-----slice</p> <p>subsrt(start，length)-----splice</p> <p>str.replace(old，new)</p> <p>str.startsWith(str，index)</p> <p>str.endsWith(str，index)</p> <p>str.repeat(number)</p> <p>str.padStart()</p> <p>str.padEnd()</p> <p>模板字符串</p> <h2 id="es6性特性"><a href="#es6性特性" class="header-anchor">#</a> ES6性特性</h2> <p>1.let 和 const关键字；</p> <p>2.解构赋值；</p> <p>3.展开运算符；</p> <p>4.set和map及其属性和方法；</p> <p>5.函数拓展---箭头函数；</p> <p>6.数组和字符串拓展。</p> <h2 id="原型链"><a href="#原型链" class="header-anchor">#</a> 原型链</h2> <p>每个函数都有个prototype属性，它指向函数的原型对象;每个对象都有个<code>__prototype__</code>属性，它指向构造函数的原型对象，所以当想要访问实例对象上的某个属性或方法时，首先会去对象本身上去找，如果找不到会向上去原型对象上找，直到找不到为止，就这样形成一个链状结构叫做原型链。</p> <h2 id="es5和es6继承"><a href="#es5和es6继承" class="header-anchor">#</a> ES5和ES6继承</h2> <p>ES5-----原型链继承，构造函数继承，组合式继承，寄生式组合继承</p> <p>1.子构造函数通过call方法继承父构造函数中的属性 <code>Father.call(this,arg1,arg2)</code></p> <p>2.子构造函数继承父构造函数中的方法 <code>Son.prototype = new Father() Son.prototype.constructor = Son</code></p> <p>ES6</p> <p>extends关键字继承父类的属性和方法
super关键字调用父类的构造函数和方法</p> <h2 id="函数调用和this指向"><a href="#函数调用和this指向" class="header-anchor">#</a> 函数调用和this指向</h2> <p>1.普通函数(当做是全局对象window的方法)  this指向window
2.对象方法  this指向方法所属对象
3.构造函数  this指向实例对象
4.DOM事件  事件对象
5.定时器    window的方法  this指向window
6.立即执行函数  this指向window</p> <p>函数模式  window</p> <p>方法模式  方法调用者</p> <p>构造器模式  实例对象</p> <p>call，apply，bind、</p> <p>箭头函数</p> <h2 id="new关键字"><a href="#new关键字" class="header-anchor">#</a> new关键字</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">myNew</span><span class="token punctuation">(</span><span class="token parameter">callback<span class="token punctuation">,</span> <span class="token operator">...</span>arg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
             <span class="token comment">//对应第一个操作：创建一个空的简单JavaScript对象</span>
            <span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> 
            <span class="token comment">//第二步：链接该对象</span>
            obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> callback<span class="token punctuation">.</span>prototype
            <span class="token comment">//第三步：将步骤1新创建的对象作为this的上下文</span>
            <span class="token function">callback</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> arg<span class="token punctuation">)</span>
            <span class="token comment">//第四步：返回该对象</span>
            <span class="token keyword">return</span> obj
<span class="token punctuation">}</span>
</code></pre></div><p>1.创建一个新对象，并继承其构造函数的prototype，是为了继承够着函数上的属性和方法；obj.<code>__proto__</code>= Foo.prototype</p> <p>2.执行构造函数，方法内的this指定为该新实例；Foo.call（obj，...arg）</p> <p>3.返回新实例。return obj</p> <h2 id="快排"><a href="#快排" class="header-anchor">#</a> 快排</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> arr          <span class="token comment">//递归终止条件</span>
    <span class="token keyword">const</span> pivot <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">0</span>        <span class="token comment">//基准点</span>
    <span class="token keyword">const</span> pivotValue <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>pivot<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    <span class="token keyword">const</span> leftArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">const</span> rightArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">val</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        val <span class="token operator">&gt;</span> pivotValue <span class="token operator">?</span> rightArr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token operator">:</span> leftArr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span> <span class="token operator">...</span><span class="token function">quickSort</span><span class="token punctuation">(</span>leftArr<span class="token punctuation">)</span><span class="token punctuation">,</span> pivotValue<span class="token punctuation">,</span> <span class="token operator">...</span><span class="token function">quickSort</span><span class="token punctuation">(</span>rightArr<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="防抖和节流"><a href="#防抖和节流" class="header-anchor">#</a> 防抖和节流</h2> <p>防抖是延迟执行，而节流是间隔执行</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> wait</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> that <span class="token operator">=</span> <span class="token keyword">this</span>
        <span class="token keyword">let</span> args <span class="token operator">=</span> arguments
        <span class="token keyword">if</span> <span class="token punctuation">(</span>timer<span class="token punctuation">)</span> <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>
        timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>that<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> wait</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> that <span class="token operator">=</span> <span class="token keyword">this</span>
        <span class="token keyword">let</span> args <span class="token operator">=</span> arguments
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                timer <span class="token operator">=</span> <span class="token keyword">null</span>
                <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>that<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="get请求和post请求有何区别"><a href="#get请求和post请求有何区别" class="header-anchor">#</a> GET请求和POST请求有何区别</h2> <ul><li>GET请求参数放在URL上，POST请求参数放在请求体里；</li> <li>POST请求相较于GET请求安全一点点，因为GET请求的参数在URL上，且有历史记录；</li> <li>GET请求参数长度有限制，POST请求参数长度可以非常大；</li> <li>GET请求能缓存，POST不能。</li></ul> <h2 id="缓存策略"><a href="#缓存策略" class="header-anchor">#</a> 缓存策略</h2> <p><strong>强缓存(不要向服务器询问的缓存)</strong></p> <p>设置Expires</p> <p>设置Cache-Control</p> <p><strong>协商缓存(需要向服务器询问缓存是否已经过期)</strong></p> <p>Etag</p> <h2 id="常见http状态码"><a href="#常见http状态码" class="header-anchor">#</a> 常见HTTP状态码</h2> <p>2xx 开头（请求成功）</p> <p>3xx 开头（重定向）301永久重定向 302临时重定向</p> <p>4xx 开头（客户端错误）</p> <p>5xx 开头（服务端错误）</p> <h2 id="http和https有何区别"><a href="#http和https有何区别" class="header-anchor">#</a> HTTP和HTTPS有何区别</h2> <ul><li>HTTPS使用443端口，而HTTP使用80；</li> <li>HTTPS需要申请证书；</li> <li>HTTP是超文本传输协议，是明文传输；HTTPS是经过SSL加密的协议，传输更安全；</li> <li>HTTPS比HTTP慢，因为HTTPS除了TCP握手的三个包，还要加上SSL握手的九个包。</li></ul> <h2 id="前端安全"><a href="#前端安全" class="header-anchor">#</a> 前端安全</h2> <p>XSS攻击：</p> <ul><li>输入检查：对输入内容中的<code>&lt;script&gt;&lt;iframe&gt;</code>等标签进行转义或者过滤-----成熟的转义库；</li> <li>设置httpOnly：很多XSS攻击目标都是窃取用户cookie伪造身份认证，设置此属性可防止JS获取cookie；</li> <li>开启CSP，即开启白名单，可阻止白名单以外的资源加载和运行。</li></ul> <p>CSRF攻击：</p> <ul><li>验证Token：浏览器请求服务器时，服务器返回一个token，每个请求都需要同时带上token和cookie才会被认为是合法请求；</li> <li>验证Referer：通过验证请求头的Referer来验证来源站点，但请求头很容易伪造；</li> <li>设置SameSite：设置cookie的SameSite，可以让cookie不随跨域请求发出，但浏览器兼容不一。</li></ul> <h2 id="mvvm"><a href="#mvvm" class="header-anchor">#</a> MVVM</h2> <p>MVVM 是 Model-View-ViewModel 缩写，也就是把 MVC 中的 Controller 演变成 ViewModel。Model 层代表数据模型，View 代表视图层。</p> <p>ViewModel 是 View 和 Model 层的桥梁，数据会绑定到 viewModel 层并自动将数据渲染到页面中，视图变化的时候会通知 viewModel 层更新数据。</p> <h2 id="vue响应式数据原理"><a href="#vue响应式数据原理" class="header-anchor">#</a> vue响应式数据原理</h2> <p>Vue 在初始化数据时，会使用 Object.defineProperty 重新定义 data 中的所有属性，当页面使用对应属性时，首先会进行依赖收集(收集当前组件的 watcher)，如果属性发生变化会通知相关依赖进行更新操作(发布订阅)。</p> <p><code>Vue2.0</code>的响应式</p> <p>核心:</p> <p>对象：通过<code>defineProperty</code>对对象已有属性值的读取和修改进行劫持；</p> <p>数组：通过重写数组<strong>更新数组的一系列更新元素的方法</strong>来实现元素修改的劫持；</p> <p>问题：</p> <p>对象直接添加的属性或者删除已有属性，界面不会自动更新</p> <p>直接通过下标替换元素或更新length，界面不会自动更新arr[1]={}</p> <p>所以<code>vue2.0</code>提供了$set方法</p> <p><code>Vue3.0</code>的响应式</p> <p>通过proxy代理<strong>拦截</strong>对data任意属性的任意操作</p> <p>通过reflect反射<strong>动态</strong>对被代理对象的相应属性进行特定的操作</p> <h2 id="nexttick实现原理是"><a href="#nexttick实现原理是" class="header-anchor">#</a> nextTick实现原理是</h2> <p><strong>在下次 DOM 更新循环结束之后执行延迟回调</strong>。nextTick 主要使用了宏任务和微任务。</p> <h2 id="vue-中组件生命周期调用顺序说一下"><a href="#vue-中组件生命周期调用顺序说一下" class="header-anchor">#</a> <strong>Vue 中组件生命周期调用顺序说一下</strong></h2> <p>组件的<strong>调用顺序</strong>都是先父后子，<strong>渲染完成</strong>的顺序是先子后父。</p> <p>组件的<strong>销毁操作</strong>是先父后子，<strong>销毁完成</strong>的顺序是先子后父。</p> <p><strong>加载渲染过程</strong></p> <p>父 beforeCreate-&gt;父 created-&gt;父 beforeMount-&gt;子 beforeCreate-&gt;子 created-&gt;子 beforeMount- &gt;子 mounted-&gt;父 mounted</p> <p><strong>子组件更新过程</strong></p> <p>父 beforeUpdate-&gt;子 beforeUpdate-&gt;子 updated-&gt;父 updated</p> <p><strong>父组件更新过程</strong></p> <p>父 beforeUpdate -&gt; 父 updated</p> <p><strong>销毁过程</strong></p> <p>父 beforeDestroy-&gt;子 beforeDestroy-&gt;子 destroyed-&gt;父 destroyed</p> <h2 id="虚拟dom和diff算法"><a href="#虚拟dom和diff算法" class="header-anchor">#</a> 虚拟DOM和diff算法</h2> <p>在浏览器中操作 DOM 是很昂贵的，频繁的操作 DOM，会产生一定的性能问题。虚拟DOM减少不必要的DOM操作，优化DOM操作的次数，借助 <code>diff</code>算法可以减少<code>dom</code>操作的范围；</p> <p>虚拟DOM本身就是一个包含真实DOM节点信息的<code>JS</code>对象，DOM如何变为虚拟DOM属于模板编译原理-----mustache，vue里虚拟DOM的实现它借鉴的了开源库snabbdom的实现。</p> <p>VDOM映射到真实 DOM 要经历 VNode 的h、diff、patch 等阶段。</p> <p><strong>1.渲染函数（h函数）产生虚拟DOM？</strong></p> <p><strong>创建虚拟节点</strong></p> <p>h函数是用来产生虚拟节点（vnode）</p> <p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1615110416449.png" alt="1615110416449"></p> <p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1615110445063.png" alt="1615110445063"></p> <p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1615110780890.png" alt="1615110780890"></p> <p><strong>h函数嵌套使用可以得到VDOM树</strong></p> <p><strong>创建patch函数-----修补，用于服务虚拟节点上树</strong></p> <p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1615110823448.png" alt="1615110823448"></p> <p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1615110850554.png" alt="1615110850554"></p> <p>2.diff算法原理</p> <p><strong>patch函数被调用</strong></p> <p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1615112917500.png" alt="1615112917500"></p> <p>执行方式：**patchVbode（）**函数，整体策略：深度优先，同层比较；</p> <p>高效性：**updateChildren（）**进行4次尝试，再借助key找到可复用的节点，key 的作用是尽可能的复用 DOM 元素。</p> <p>someNode（sel和key）：只有同一个vnode，才进行精细化比较，否则暴力删除；只进行同层比较，不进行跨层比较，暴力拆除。</p> <p><strong>Vue2 的核心 Diff 算法采用了双端比较的算法，同时从新旧 children 的两端开始进行比较，借助 key 值找到可复用的节点，再进行相关操作。Vue3在借鉴一些算法的基础上较Vue2有了提升。</strong></p> <p>diff算法是发生在虚拟DOM上，对新旧虚拟DOM进行精细化比对，算出应该如何最小更新，最后映射到真的DOM上；</p> <h2 id="vue组件间6种通信方式"><a href="#vue组件间6种通信方式" class="header-anchor">#</a> <code>Vue</code>组件间6种通信方式</h2> <p>1.父子组件传值 props和$emit('event',value)；</p> <p>2.事件总线(事件中心)：通过一个空的<code>Vue</code>实例作为中央事件总线（事件中心），用它来触发事件和监听事件；</p> <div class="language-shell extra-class"><pre class="language-shell"><code>var <span class="token assign-left variable">Event</span><span class="token operator">=</span>new Vue<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Event.<span class="token variable">$emit</span><span class="token punctuation">(</span><span class="token string">'event'</span>,data<span class="token punctuation">)</span><span class="token punctuation">;</span>
Event.<span class="token variable">$on</span><span class="token punctuation">(</span><span class="token string">'event'</span>,data <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Event.<span class="token variable">$off</span><span class="token punctuation">(</span><span class="token string">'event'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>3.<code>vuex</code></p> <p>4.provide/inject：<strong>依赖和注入，祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量</strong>。主要在开发<strong>高阶插件/组件库</strong>时使用，并不推荐用于普通应用程序代码中。</p> <p><strong>provide 和 inject 绑定并不是可响应的</strong>。祖先组件数据改变，子孙组件是不改变的。</p> <p>解决办法：</p> <p>①provide 祖先组件的实例，但这个实例上会挂载很多没有必要的东西；</p> <p>②使用 2.6 最新 <code>API Vue.observable</code>优化响应式 provide(推荐)。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function-name function">provide</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	this.theme <span class="token operator">=</span> Vue.observable<span class="token punctuation">(</span><span class="token punctuation">{</span>
 	color: <span class="token string">&quot;blue&quot;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token builtin class-name">return</span> <span class="token punctuation">{</span>
	theme: this.theme
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>,
</code></pre></div><p>5.$parents/$children和$ref：<strong>直接得到组件实例</strong>，使用后可以直接调用组件的方法或访问数据；这种方法主要目的是作为访问组件的<strong>应急方法</strong>，更推荐用 props 和 $emit 实现父子组件通信；</p> <p>6.<code>$attrs</code>/<code>$listeners</code>：<strong>实现多级嵌套组件(隔代)通信</strong>，通常使用的方法是通过<code>vuex</code>，如果仅仅是传递数据，而不做中间处理，使用 <code>vuex</code> 处理，就有有点大材小用；<code>Vue2.4</code> 版本提供了另一种方法-<code>$attrs/$listeners</code></p> <p><strong>默认情况下父作用域不被认作props的属性会作为普通的HTML特性应用在子组件的根元素上</strong>；</p> <p>在2.4中新增选项<code>inheritAttrs</code> <code>inheritAttrs</code>的默认值为true，将<code>inheritAttrs</code>的值设为false，这些默认的行为会禁止掉。但是通过实例属性<code>$attrs</code> ，不仅可以将这些特性生效，且可以通过v-bind 绑定到子组件的非根元素上。</p> <p><strong>通俗的理解为：子辈可以通过<code>$attrs</code>将未在自己组件内注册的祖辈传递下来的参数接收来，并传递孙辈。</strong></p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child-dom</span>
      <span class="token attr-name">:foo</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>foo<span class="token punctuation">&quot;</span></span>
      <span class="token attr-name">:coo</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>foo<span class="token punctuation">&quot;</span></span>
     <span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>child-dom</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
   <span class="token keyword">import</span> childDom <span class="token keyword">from</span> <span class="token string">&quot;./ChildDom.vue&quot;</span><span class="token punctuation">;</span>
   <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
     <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span>
          foo<span class="token operator">:</span><span class="token string">&quot;Hello, world&quot;</span><span class="token punctuation">,</span>
          coo<span class="token operator">:</span><span class="token string">&quot;Hello,rui&quot;</span>
        <span class="token punctuation">}</span>
     <span class="token punctuation">}</span><span class="token punctuation">,</span>
     components<span class="token operator">:</span><span class="token punctuation">{</span>childDom<span class="token punctuation">}</span><span class="token punctuation">,</span>
   <span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>

子组件child-dom代码如下
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>foo:{{foo}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
 name<span class="token operator">:</span><span class="token string">'child-dom'</span>
 props<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>我们在b组件上 绑定 v-on=”$listeners”, 在a组件中，监听c组件触发的事件。就能把c组件发出的数据，传递给a组件。</p> <div class="language- extra-class"><pre class="language-text"><code>a：@upRocket=&quot;reciveRocket&quot;
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>b：
&lt;childDomChild v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot;&gt;&lt;/childDomChild&gt;
</code></pre></div><div class="language-shell extra-class"><pre class="language-shell"><code>c：
<span class="token function-name function">startUpRocket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
this.<span class="token variable">$emit</span><span class="token punctuation">(</span><span class="token string">&quot;upRocket&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="hash-路由和-history-路由实现原理"><a href="#hash-路由和-history-路由实现原理" class="header-anchor">#</a> hash 路由和 history 路由实现原理</h2> <p>location.hash 的值实际就是 URL 中#后面的东西。</p> <p>history 实际采用了 H5 中提供的 API 来实现，主要有 **history.pushState()**和 <strong>history.replaceState()</strong>。</p> <h2 id="服务端渲染ssr和nuxt框架"><a href="#服务端渲染ssr和nuxt框架" class="header-anchor">#</a> 服务端渲染SSR和nuxt框架</h2> <p>SSR 也就是服务端渲染，也就是将 Vue 在客户端把标签渲染成 HTML 的工作放在服务端完成，然后再把 html 直接返回给客户端，服务器会有更大的负载需求。</p> <p>SSR 有着更好的 SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，</p> <p>服务器端渲染只支持 beforeCreate 和 created 两个钩子，当我们需要一些外部扩展库时需要特殊处理，</p> <p>服务端渲染应用程序也需要处于 Node.js 的运行环境。</p> <h2 id="vue性能优化"><a href="#vue性能优化" class="header-anchor">#</a> Vue性能优化</h2> <p><strong>编码阶段</strong></p> <p>路由懒加载</p> <p>防抖、节流</p> <p>第三方模块按需导入</p> <p>图片懒加载</p> <p>keep-alive 缓存组件</p> <p>在更多的情况下，使用 v-if 替代 v-show</p> <p>开发智能事件处理程序-----事件委托</p> <p>精简js和css</p> <p><strong>打包优化</strong></p> <p>在 webpack 设置 externals 选项，可以忽略不需要打包的库，使用 CDN（内容分发网络）</p> <p>使用 gzip 压缩文件</p> <p>配置Expires 或 Cache-Control或ETags优化缓存</p> <h2 id="webpack配置-vue-cli脚手架的官网配置模块"><a href="#webpack配置-vue-cli脚手架的官网配置模块" class="header-anchor">#</a> WebPack配置---vue-cli脚手架的官网配置模块</h2> <p><strong>vue inspect</strong></p> <p>1.vue-cli3.x开始默认是没有webpack的配置文件，我们在vue里面是通过vue.config.js配置项目webpack;</p> <p>2.配置跨域是在deserve节点，具体配置项根据webpack相关文档；</p> <p>3.打包前端项目上线的时候，服务器放了多个网站，会有多个基地址，打包的时候需要单独配置publicPath这个目录，解决一些项目本地跑可以，上线打包出现资源文件404问题。</p> <p>4.configureWebpack配置externals，配置别名等；</p> <p>5.chanwebpack配置一些webpack的插件以及一些loader</p> <p>chainWebpack-----配置开发和发布模式</p> <p><strong>我们项目里面写webpack，一般是找个模板，再根据webpack官网和vue-cli官网结合起来进行模块配置。</strong></p> <p><strong>如何启动HRM</strong></p> <ol><li>使用了<code>new webpack.HotModuleReplacementPlugin()</code>;</li> <li>设置<code>devServer</code>选项中的<code>hot</code>字段为<code>true</code>;</li> <li>配置相关loader文件。</li></ol> <h2 id="项目难点"><a href="#项目难点" class="header-anchor">#</a> 项目难点</h2> <h3 id="埋点"><a href="#埋点" class="header-anchor">#</a> 埋点</h3> <p>前端埋点： 是一种手段，它的目的是上报相关行为数据，相关人员以数据为依据来分析产品在用户端的使用情况，根据分析出来的结果辅助产品优化、迭代。</p> <p>方案：</p> <p>手动代理埋点：用户触发某个动作后手动上报数据；（发送埋点请求）</p> <p>优点：是最准确的，可以满足很多定制化的需求；</p> <p>缺点：埋点逻辑与业务代码耦合到一起，不利于代码维护和复用。</p> <p>命令式埋点和声明式埋点:</p> <p>命令式埋点：在一些事件操作的回调函数中进行埋点。</p> <p>声明式埋点：将埋点信息封装在自定义属性中，通过<code>sdk</code>识别自定义属性然后获取埋点数据。自定义指令实现埋点数据统计。</p> <p>可视化埋点（无痕埋点）：通过可视化工具配置采集节点，指定自己想要监测的元素和属性，业界比较有名的是 <code>Mixpanel</code>;</p> <p>优点：可以做到按需配置，又不会像全埋点那样产生大量的无用数据；
缺点：比较难加载一些运行时参数；页面结构发生变化的时候，可能就需要进行部分重新配置。</p> <p>无埋点：也叫“全埋点”，前端自动采集全部事件并上报埋点数据，在后端数据计算时过滤出有用数据；</p> <p>优点：收集用户的所有端上行为，很全面；
缺点：无效的数据很多、上报数据量大。</p> <h2 id="http-2-0新特性"><a href="#http-2-0新特性" class="header-anchor">#</a> HTTP/2.0新特性</h2> <p>多路复用： 即多个请求都通过一个TCP连接并发地完成；
服务端推送： 服务端能够主动把资源推送给客户端；
新的二进制格式： HTTP/2采用二进制格式传输数据，相比于HTTP/1.1的文本格式，二进制格式具有更好的解析性和拓展性；
header压缩： HTTP/2压缩消息头，减少了传输数据的大小。</p> <h2 id="http-3-0"><a href="#http-3-0" class="header-anchor">#</a> HTTP/3.0</h2> <p>HTTP/2在UDP的基础上实现多路复用、0-RTT、TLS加密、流量控制、丢包重传等功能。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">6/24/2022, 10:48:30 PM</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.5be7a91d.js" defer></script><script src="/assets/js/2.b81dff88.js" defer></script><script src="/assets/js/10.c01ab306.js" defer></script>
  </body>
</html>
